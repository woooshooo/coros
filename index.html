<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Running Stats Analyzer by Web</title>

    <!-- PWA Manifest Link -->
    <link rel="manifest" href="./manifest.json">
    
    <!-- === iOS/Safari Specific PWA Tags for Icon and Name === -->
    <!-- Forces iOS to run in full-screen mode like a native app -->
    <meta name="apple-mobile-web-app-capable" content="yes"> 
    <!-- Sets the text under the icon (Home Screen Name) -->
    <meta name="apple-mobile-web-app-title" content="RunStats"> 
    <!-- Links to the high-resolution icon used by iOS -->
    <link rel="apple-touch-icon" href="/android-chrome-192x192.png"> 
    <!-- ======================================================= -->

    <!-- Load Tailwind CSS Library FIRST -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Load Tailwind Configuration SECOND (must run after the library is loaded) -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'dark-bg': '#191919',   // Darker shade for main background
                        'dark-card': '#232323', // Lighter shade for card/sections
                    }
                }
            }
        }
    </script>
    
    <!-- Load React Core Library THIRD -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <!-- Load ReactDOM FOURTH -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Load Babel for JSX compilation (Largest potential bottleneck) -->
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Load html2canvas for capturing DOM as image -->
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <!-- Load Chart.js for Visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>

    <style>
        /* Define Inter font and ensure dark background */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom class for collapse transition - keeps animation smooth */
        .collapsible {
            transition: max-height 0.3s ease-in-out, opacity 0.3s ease-in-out;
            overflow: hidden;
        }
        /* Style the file input for better visual appearance */
        input[type="file"]::file-selector-button {
            background-color: #374151; /* gray-700 */
            color: white;
            border: 1px solid #4b5563; /* gray-600 */
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.15s ease-in-out;
        }
        input[type="file"]::file-selector-button:hover {
            background-color: #4b5563; /* gray-600 */
        }
        /* Light Mode specific file input button style */
        .light-mode input[type="file"]::file-selector-button {
            background-color: #E5E7EB; /* gray-200 */
            color: #1F2937; /* gray-800 */
            border-color: #D1D5DB; /* gray-300 */
        }
        .light-mode input[type="file"]::file-selector-button:hover {
            background-color: #D1D5DB; /* gray-300 */
        }
        /* Style for editable cells */
        .edit-input {
            width: 100%;
            padding: 2px 4px;
            border-radius: 4px;
            font-size: 0.875rem; /* text-sm */
            box-sizing: border-box;
            background-color: transparent;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useMemo, useEffect } = React;

        // --- Inline SVG Icons (Optimized for minimal DOM changes) ---

        // Added 'align-middle' and 'inline-block' to the default className for perfect vertical centering with text.
        const Icon = ({ path, className = "w-4 h-4 mr-2 inline-block align-middle" }) => (
            <svg 
                xmlns="http://www.w3.org/2000/svg" 
                width="24" 
                height="24" 
                viewBox="0 0 24 24" 
                fill="none" 
                stroke="currentColor" 
                strokeWidth="2" 
                strokeLinecap="round" 
                strokeLinejoin="round" 
                className={className}
            >
                {path}
            </svg>
        );

        // Define icons only once for use throughout the component
        const RefreshCwIcon = (props) => ( <Icon {...props} path={<><path d="M23 4v6h-6"/><path d="M2 12s2-2 4-2h12s4 2 4 2"/><path d="M1 20v-6h6"/><path d="M22 12s-2 2-4 2H6s-4-2-4-2"/></>}/> );
        const PlayIcon = (props) => ( <Icon {...props} path={<polygon points="6 3 20 12 6 21 6 3"/>}/> );
        const BarChartIcon = (props) => ( <Icon {...props} path={<><line x1="12" x2="12" y1="20" y2="10"/><line x1="18" x2="18" y1="20" y2="4"/><line x1="6" x2="6" y1="20" y2="16"/></>}/> );
        const UploadIcon = (props) => ( <Icon {...props} path={<><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/></>}/> );
        const Loader2Icon = (props) => ( <Icon {...props} path={<path d="M21 12a9 9 0 1 1-6.219-8.56"/>}/> );
        const ImageIcon = (props) => ( <Icon {...props} path={<><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/></>}/> );
        const FilterIcon = (props) => ( <Icon {...props} path={<polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/>}/> );
        const ChevronDownIcon = (props) => ( <Icon {...props} path={<path d="m6 9 6 6 6-6"/>}/> );
        const ChevronUpIcon = (props) => ( <Icon {...props} path={<path d="m18 15-6-6-6 6"/>}/> );
        const ClockIcon = (props) => ( <Icon {...props} path={<><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></>}/> );
        const StopwatchIcon = (props) => ( <Icon {...props} path={<><circle cx="12" cy="13" r="10"/><path d="M12 2v2"/><path d="m4.9 4.9 1.4 1.4"/><path d="m19.1 4.9-1.4 1.4"/><path d="M15 13H12V9"/></>}/> );
        const ActivityIcon = (props) => ( <Icon {...props} path={<path d="M22 12h-4l-3 9L9 3l-3 9H2"/>}/> );
        const ListOrderedIcon = (props) => ( <Icon {...props} path={<><line x1="10" x2="21" y1="6" y2="6"/><line x1="10" x2="21" y1="12" y2="12"/><line x1="10" x2="21" y1="18" y2="18"/><path d="M4 6h1.5v-1a.5.5 0 0 0-.5-.5H3"/><path d="M3 10.8V12a1 1 0 0 0 1 1h2"/><path d="M3 18h2.5c.5 0 .5.5.5 1s-.5 1-.5 1H3"/></>}/> );
        const SunIcon = (props) => ( <Icon {...props} path={<><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></>}/> );
        const MoonIcon = (props) => ( <Icon {...props} path={<path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/>}/> );
        const ShareIcon = (props) => ( <Icon {...props} path={<><path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"/><polyline points="16 6 12 2 8 6"/><line x1="12" x2="12" y1="2" y2="15"/></>}/> );
        const EditIcon = (props) => ( <Icon {...props} path={<path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/>}/> );
        // FIX: Only one JSX fragment wrapper is used.
        const SaveIcon = (props) => ( <Icon {...props} path={<><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 7 14 7"/></>}/> );
        // FIX: Only one JSX fragment wrapper is used.
        const XIcon = (props) => ( <Icon {...props} path={<><path d="M18 6 6 18"/><path d="m6 6 12 12"/></>}/> );


        // --- Utility Functions for Time and Pace Calculation ---

        /**
         * Converts a time string (e.g., "6:00.00", "1:14:32.47", or just "5") to total seconds.
         * If the input is a single number (no colon), it is assumed to be total minutes.
         * @param {string} timeStr - Time string in H:MM:SS.SS, MM:SS.SS, or M format.
         * @returns {number} Total seconds.
         */
        const timeToSeconds = (timeStr) => {
            const cleanedStr = timeStr.trim();
            if (!cleanedStr) return 0;

            if (!cleanedStr.includes(':')) {
                const minutes = parseFloat(cleanedStr);
                if (!isNaN(minutes)) {
                    return minutes * 60;
                }
            }

            const parts = cleanedStr.split(':').map(p => parseFloat(p));
            let totalSeconds = 0;

            if (parts.length === 3) {
                totalSeconds = parts[0] * 3600 + parts[1] * 60 + parts[2];
            } else if (parts.length === 2) {
                totalSeconds = parts[0] * 60 + parts[1];
            }
            
            return totalSeconds;
        };

        /**
         * Converts total seconds back to a display string in M:SS.SS or H:MM:SS.SS format.
         * @param {number} totalSeconds - Total time in seconds.
         * @returns {string} Formatted time string.
         */
        const secondsToTimeString = (totalSeconds) => {
            if (isNaN(totalSeconds) || totalSeconds < 0) return '0:00.00';

            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;

            const formatTime = (time) => time.toFixed(2).padStart(5, '0');
            const formatMinutes = (min) => String(min).padStart(2, '0');

            if (hours > 0) {
                return `${hours}:${formatMinutes(minutes)}:${formatTime(seconds)}`;
            } else {
                return `${minutes}:${formatTime(seconds)}`;
            }
        };

        /**
         * Converts pace string (e.g., "5'24\"/km") to seconds per unit.
         * @param {string} paceStr - Pace string in M'SS"/unit format.
         * @returns {number | null} Pace in seconds per unit or null on error.
         */
        const paceToSeconds = (paceStr) => {
            if (!paceStr || paceStr.includes('--')) return null;

            // Use regex to extract minutes and seconds
            const match = paceStr.match(/(\d+)'(\d+)"/);
            if (match) {
                const minutes = parseInt(match[1], 10);
                const seconds = parseInt(match[2], 10);
                return (minutes * 60) + seconds;
            }
            return null;
        };


        /**
         * Calculates pace (time per km or time per 100m) and returns a string in M'SS"/unit format.
         * @param {number} timeSeconds - Time for the lap in seconds.
         * @param {number} distanceKm - Distance for the lap in kilometers.
         * @param {boolean} isSwimMode - If true, calculates pace per 100m.
         * @returns {string} Formatted pace string (e.g., "5'24"/km" or "1'30"/100m").
         */
        const calculatePace = (timeSeconds, distanceKm, isSwimMode) => {
            if (distanceKm <= 0 || timeSeconds <= 0) return `--/${isSwimMode ? '100m' : 'km'}`;
            
            let paceSecondsPerUnit;
            let unit;

            if (isSwimMode) {
                // Pace per 100 meters: Convert distance from km to 100m units (km * 10)
                const distanceInHundredsOfMeters = distanceKm * 10;
                if (distanceInHundredsOfMeters <= 0) return '--/100m';

                paceSecondsPerUnit = timeSeconds / distanceInHundredsOfMeters;
                unit = '/100m';
            } else {
                // Pace per Kilometer
                paceSecondsPerUnit = timeSeconds / distanceKm;
                unit = '/km';
            }

            const minutes = Math.floor(paceSecondsPerUnit / 60);
            const seconds = Math.round(paceSecondsPerUnit % 60);

            return `${minutes}'${String(seconds).padStart(2, '0')}"${unit}`;
        };
        
        // UPDATED LAP TYPES
        const LAP_TYPES = [
            'Run', 'Rest', 'Warm Up', 'Cool Down', 
            'Freestyle', 'Breaststroke', 'Backstroke', 'Butterfly'
        ];
        const RUN_TYPES_BASE = ['Warm Up', 'Run', 'Rest', 'Cool Down'];
        const SWIM_TYPES = ['Freestyle', 'Breaststroke', 'Backstroke', 'Butterfly'];


        // --- Data Persistence Utilities ---
        const STORAGE_KEY = 'runStatsLaps';

        const getInitialLaps = () => {
            try {
                const storedLaps = localStorage.getItem(STORAGE_KEY);
                if (storedLaps) {
                    return JSON.parse(storedLaps);
                }
            } catch (error) {
                console.error("Error reading from localStorage:", error);
            }
            return [];
        };
        
        const saveLapsToStorage = (laps) => {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(laps));
            } catch (error) {
                console.error("Error saving to localStorage:", error);
            }
        };


        // --- Component: Lap Row ---

        const LapRow = ({ lap, index, isTotal = false, isDarkMode, isEditing, onSave, onCancel, inputClass, activityType }) => {
            const isRest = lap.type === 'Rest';
            const isSwim = activityType === 'SWIM';
            
            // State for holding temporary edits
            const [editLap, setEditLap] = useState({ 
                type: lap.type, 
                // Use rawDistance if available, otherwise use formatted distance from computed lap
                distance: lap.rawDistance !== undefined ? lap.rawDistance : parseFloat(lap.distance).toFixed(2),
                time: lap.rawTime || lap.time 
            });

            // Effects to update edit state when lap props change (e.g., after initial load or image analysis)
            useEffect(() => {
                // Ensure editLap reflects the current lap's source data when the lap prop changes
                setEditLap({ 
                    type: lap.type, 
                    distance: lap.rawDistance !== undefined ? lap.rawDistance : parseFloat(lap.distance).toFixed(2), 
                    time: lap.rawTime !== undefined ? lap.rawTime : lap.time 
                });
            }, [lap.type, lap.rawDistance, lap.rawTime, lap.distance, lap.time]);

            
            // --- Handlers for Editing ---
            const handleEditChange = (e) => {
                const { name, value } = e.target;
                setEditLap(prev => ({ ...prev, [name]: value }));
            };

            const handleSave = () => {
                const dist = parseFloat(editLap.distance);
                const timeSec = timeToSeconds(editLap.time);

                if (dist > 0 && timeSec > 0 && dist < 1000) { // Basic sanity check: distance < 1000km
                    onSave(index, { 
                        type: editLap.type, 
                        distance: editLap.distance, // Keep as string for raw data fidelity
                        time: editLap.time // Store raw time input
                    });
                } else {
                    alert("Validation failed: Distance must be > 0 (and less than 1000 km) and Time must be valid (e.g., '5' or '5:30.00').");
                }
            };

            const handleCancel = () => {
                // Revert to original computed values and exit editing
                setEditLap({ 
                    type: lap.type, 
                    distance: lap.rawDistance !== undefined ? lap.rawDistance : parseFloat(lap.distance).toFixed(2), 
                    time: lap.rawTime !== undefined ? lap.rawTime : lap.time 
                });
                onCancel();
            };


            // --- Styling ---
            let rowClass;
            let paceColor = isDarkMode ? 'text-white' : 'text-gray-900';
            let textColor = isDarkMode ? 'text-white' : 'text-gray-900';
            let subtleColor = isDarkMode ? 'text-gray-400' : 'text-gray-500';

            if (isTotal) {
                // Apply custom dark color
                rowClass = isDarkMode ? 'bg-dark-bg font-bold total-row-bg' : 'bg-gray-200 font-bold total-row-bg'; 
            } else if (isRest) {
                rowClass = isDarkMode ? 'text-gray-400' : 'text-gray-600';
                textColor = isRest ? (isDarkMode ? 'text-gray-400' : 'text-gray-600') : textColor;
            } else {
                rowClass = textColor;
            }
            
            // Distance display logic (km or meters)
            const displayDistance = (dist) => {
                if (!dist && dist !== 0) return '0.00';
                const distNum = parseFloat(dist);
                if (isSwim) {
                    // Convert KM to Meters for display (km * 1000)
                    return `${(distNum * 1000).toFixed(0)} m`;
                }
                return `${distNum.toFixed(2)} km`;
            }

            if (isTotal) {
                 // Total row display (no editing)
                 return (
                    <div className={`grid grid-cols-12 py-3 px-2 ${rowClass}`} id="total-lap-row">
                        <div className={`col-span-3 text-sm flex items-center ${textColor}`}>{lap.type}</div>
                        <div className={`col-span-3 text-sm text-right ${textColor}`}>{displayDistance(lap.distance)}</div>
                        <div className={`col-span-3 text-sm text-right ${textColor}`}>{lap.time || '--'}</div>
                        <div className={`col-span-3 text-sm text-right ${paceColor}`}>{lap.pace || '--'}</div>
                    </div>
                );
            }

            // --- Render Edit Mode vs. View Mode ---
            return (
                <div className={`grid grid-cols-12 py-3 px-2 ${rowClass}`}>
                    
                    {/* Lap Type / Control Buttons */}
                    <div className={`col-span-3 text-sm flex items-center space-x-1 ${textColor}`}>
                        <span className={`w-4 mr-1 ${subtleColor}`}>{index + 1}</span>
                        
                        {isEditing ? (
                            <div className='flex flex-col space-y-1 w-full'>
                                <select
                                    name="type"
                                    value={editLap.type}
                                    onChange={handleEditChange}
                                    className={`edit-input text-xs ${inputClass}`}
                                >
                                    {LAP_TYPES.map(type => <option key={type} value={type}>{type}</option>)}
                                </select>
                                <div className="flex space-x-1 mt-1">
                                    <button 
                                        onClick={handleSave} 
                                        className={`bg-green-600 hover:bg-green-700 text-white p-1 rounded-sm flex items-center justify-center text-xs`}
                                        title="Save Edits"
                                    >
                                        <SaveIcon className="w-3 h-3 mr-0"/>
                                    </button>
                                    <button 
                                        onClick={handleCancel} 
                                        className={`bg-red-600 hover:bg-red-700 text-white p-1 rounded-sm flex items-center justify-center text-xs`}
                                        title="Cancel Edits"
                                    >
                                        <XIcon className="w-3 h-3 mr-0"/>
                                    </button>
                                </div>
                            </div>
                        ) : (
                            <span>{lap.type}</span>
                        )}
                    </div>
                    
                    {/* Distance (km or meters input in km) */}
                    <div className={`col-span-3 text-sm text-right ${textColor}`}>
                        {isEditing ? (
                            <input
                                type="number"
                                name="distance"
                                value={editLap.distance}
                                onChange={handleEditChange}
                                step="0.01"
                                min="0"
                                className={`edit-input text-right ${inputClass}`}
                                placeholder={`Distance (km)`} // Input remains KM to maintain data consistency
                            />
                        ) : (
                            displayDistance(lap.distance)
                        )}
                    </div>
                    
                    {/* Time */}
                    <div className={`col-span-3 text-sm text-right ${textColor}`}>
                        {isEditing ? (
                            <input
                                type="text"
                                name="time"
                                value={editLap.time}
                                onChange={handleEditChange}
                                placeholder="M:SS.ss"
                                className={`edit-input text-right ${inputClass}`}
                            />
                        ) : (
                            lap.time || '--'
                        )}
                    </div>

                    {/* Pace (Always Displayed) */}
                    <div className={`col-span-3 text-sm text-right ${paceColor}`}>
                        {lap.pace || (isRest ? `--/${isSwim ? '100m' : 'km'}` : '--')}
                    </div>
                </div>
            );
        };

        // --- Component: Filter Button ---

        const FilterButton = ({ type, currentFilter, setFilter, label, isDarkMode }) => {
            const isActive = currentFilter === type;

            const activeClass = 'bg-indigo-600 text-white shadow-md';
            const inactiveDark = 'bg-dark-card text-gray-300 hover:bg-gray-700'; // Using dark-card
            const inactiveLight = 'bg-gray-200 text-gray-700 hover:bg-gray-300';
            
            const inactiveClass = isDarkMode ? inactiveDark : inactiveLight;

            return (
                <button
                    onClick={() => setFilter(type)}
                    className={`flex-1 py-2 px-1 rounded-lg font-medium transition duration-150 whitespace-nowrap ${
                        isActive ? activeClass : inactiveClass
                    }`}
                >
                    {label}
                </button>
            );
        };

        // --- Component: Chart Type Button ---
        const ChartTypeButton = ({ type, currentType, setType, label, isDarkMode }) => {
            const isActive = currentType === type;
            const activeClass = 'bg-indigo-600 text-white shadow-md';
            const inactiveDark = 'bg-gray-700 text-gray-300 hover:bg-gray-600';
            const inactiveLight = 'bg-gray-200 text-gray-700 hover:bg-gray-300';
            
            const inactiveClass = isDarkMode ? inactiveDark : inactiveLight;
            const IconComponent = type === 'line' ? BarChartIcon : ListOrderedIcon; // Using ListOrdered as placeholder for bar

            return (
                <button
                    onClick={() => setType(type)}
                    className={`flex-1 py-2 px-3 rounded-lg font-medium transition duration-150 flex items-center justify-center whitespace-nowrap text-xs ${
                        isActive ? activeClass : inactiveClass
                    }`}
                >
                    <IconComponent className="w-3 h-3 mr-1" stroke="currentColor"/> {label}
                </button>
            );
        };


        // --- Component: Pace Chart ---

        const PaceChart = ({ filteredLaps, isDarkMode, activityType, chartType }) => {
            const canvasRef = React.useRef(null);
            const chartRef = React.useRef(null);

            const isSwimMode = activityType === 'SWIM';
            const unitLabel = isSwimMode ? 'Pace (s/100m)' : 'Pace (s/km)';
            const isHorizontalBar = chartType === 'horizontalBar';
            const chartJsType = isHorizontalBar ? 'bar' : 'line';
            const indexAxis = isHorizontalBar ? 'y' : 'x';

            const data = useMemo(() => {
                const labels = [];
                const paceData = [];
                const paceColors = [];
                const borderColors = [];
                
                filteredLaps.forEach((lap, index) => {
                    const paceInSeconds = paceToSeconds(lap.pace);

                    if (paceInSeconds !== null) {
                        labels.push(`Lap ${index + 1}`);
                        paceData.push(paceInSeconds);
                        
                        // Determine color (e.g., blue for activity, gray for rest)
                        const color = lap.type === 'Rest' ? '#6B7280' : (isDarkMode ? '#5E97F6' : '#3B82F6'); 
                        paceColors.push(color);
                        borderColors.push(isDarkMode ? '#5E97F6' : '#3B82F6');
                    }
                });
                
                return { labels, paceData, paceColors, borderColors };
            }, [filteredLaps, isDarkMode, activityType]);

            useEffect(() => {
                // Chart.js requires a context to draw.
                if (!canvasRef.current || data.paceData.length === 0) return;

                // Destroy previous chart instance if it exists
                if (chartRef.current) {
                    chartRef.current.destroy();
                }
                
                const ctx = canvasRef.current.getContext('2d');
                
                // Define common chart elements based on theme
                const gridColor = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
                const tickColor = isDarkMode ? '#A0AEC0' : '#4A5568';
                const labelColor = isDarkMode ? '#FFFFFF' : '#1A202C';

                const datasetConfig = {
                    label: unitLabel,
                    data: data.paceData,
                    borderColor: data.borderColors,
                    borderWidth: 2,
                    
                    // Specific settings for Line vs Bar
                    backgroundColor: isHorizontalBar 
                        ? data.paceColors // Use solid color for bar fill
                        : (isDarkMode ? 'rgba(94, 151, 246, 0.4)' : 'rgba(59, 130, 246, 0.4)'), // Area fill for line chart
                    
                    fill: !isHorizontalBar, // Only fill for line chart
                    tension: isHorizontalBar ? 0 : 0.3, // Smoother curve only for line
                    pointRadius: isHorizontalBar ? 0 : 4,
                    pointHoverRadius: isHorizontalBar ? 0 : 6,
                    pointBackgroundColor: data.paceColors,
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2,

                    // Bar specific properties
                    barPercentage: isHorizontalBar ? 0.9 : 0.8,
                    categoryPercentage: isHorizontalBar ? 0.9 : 0.8,
                };

                const chartConfig = {
                    type: chartJsType,
                    data: {
                        labels: data.labels,
                        datasets: [datasetConfig]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        indexAxis: indexAxis, // 'x' for Line, 'y' for Horizontal Bar

                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    label: (context) => {
                                        const paceSeconds = context.raw;
                                        const minutes = Math.floor(paceSeconds / 60);
                                        const seconds = Math.round(paceSeconds % 60);
                                        return `Pace: ${minutes}'${String(seconds).padStart(2, '0')}"${isSwimMode ? '/100m' : '/km'}`;
                                    }
                                }
                            }
                        },
                        scales: {
                            [indexAxis === 'x' ? 'y' : 'x']: { // The pace axis
                                title: {
                                    display: true,
                                    text: unitLabel,
                                    color: labelColor,
                                    font: { family: 'Inter', size: 14 }
                                },
                                ticks: {
                                    color: tickColor,
                                    // Format Y/X axis ticks to M:SS
                                    callback: function(value) {
                                        const minutes = Math.floor(value / 60);
                                        const seconds = Math.round(value % 60);
                                        return `${minutes}'${String(seconds).padStart(2, '0')}"`;
                                    }
                                },
                                grid: {
                                    color: gridColor,
                                    drawBorder: true,
                                    borderColor: tickColor,
                                },
                                beginAtZero: false,
                                reverse: false, 
                            },
                            [indexAxis === 'x' ? 'x' : 'y']: { // The Lap label axis
                                ticks: {
                                    color: tickColor,
                                },
                                grid: {
                                    display: false,
                                },
                            }
                        }
                    }
                };

                // Create the new chart instance
                chartRef.current = new Chart(ctx, chartConfig);

                // Cleanup function to destroy the chart when the component unmounts or dependencies change
                return () => {
                    if (chartRef.current) {
                        chartRef.current.destroy();
                    }
                };
            }, [data, isDarkMode, unitLabel, chartType]); // Rerun if chartType changes

            return (
                <div className="w-full relative" style={{ height: isHorizontalBar ? 'auto' : '300px' }}>
                    {data.paceData.length > 0 ? (
                        <canvas ref={canvasRef} role="img" aria-label="Lap Pace Chart" 
                            style={isHorizontalBar ? { minHeight: `${data.labels.length * 30}px`, maxHeight: '600px' } : {}}
                        ></canvas>
                    ) : (
                        <div className={`text-center py-8 ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}>
                            No activity laps available to chart in the current view.
                        </div>
                    )}
                </div>
            );
        };

        // --- Main Application Component ---

        const App = () => {
            // UPDATED: Initialize laps state by attempting to load from localStorage
            const [laps, setLaps] = useState(getInitialLaps);
            const [newLap, setNewLap] = useState({
                type: 'Run',
                distance: '',
                time: '',
            });
            
            const [uploadedImage, setUploadedImage] = useState(null);
            const [isLoading, setIsLoading] = useState(false);
            const [apiError, setApiError] = useState('');
            
            // Hardcoded API Key: WARNING - EXPOSED CLIENT-SIDE
            const [apiKey] = useState("AIzaSyAt_eZoxQ2jjZTizFeNWUWcc97DnutbhYg"); 
            
            const [filterType, setFilterType] = useState('All'); 
            const [isInputExpanded, setIsInputExpanded] = useState(false); 
            const [isUploadExpanded, setIsUploadExpanded] = useState(false);
            const [isEditing, setIsEditing] = useState(false); // NEW: Edit Mode State
            // NEW STATE for Visualization Collapse
            const [isVisualizationExpanded, setIsVisualizationExpanded] = useState(false);
            // NEW STATE for Chart Type
            const [chartType, setChartType] = useState('line');

            // NEW: Dark Mode State, defaulting to true
            const [isDarkMode, setIsDarkMode] = useState(true);
            
            // State to track if swim data is present, controlling UI units and filter visibility
            const [showSwimFilters, setShowSwimFilters] = useState(false);
            // State to hold the detected activity type (RUN or SWIM)
            const [activityType, setActivityType] = useState('RUN');
            // NEW: Set of existing lap types for dynamic filter visibility
            const [existingLapTypes, setExistingLapTypes] = useState(new Set());


            // --- Effects to Manage Global State ---

            // EFFECT 1: Check for swim data and update units/filters/existing types
            useEffect(() => {
                const types = new Set(laps.map(lap => lap.type));
                setExistingLapTypes(types);

                const hasSwimLaps = laps.some(lap => SWIM_TYPES.includes(lap.type));
                setShowSwimFilters(hasSwimLaps);
                
                // Set application-wide activity context based on unfiltered data
                if (hasSwimLaps) {
                     setActivityType('SWIM');
                } else {
                     setActivityType('RUN');
                }
                
                // If the current filter type is no longer in the laps, reset to All
                if (filterType !== 'All' && !types.has(filterType)) {
                    setFilterType('All');
                }

            }, [laps, filterType]);

            // EFFECT 2: Save laps state to localStorage whenever the laps array changes
            useEffect(() => {
                saveLapsToStorage(laps);
            }, [laps]);


            // PWA Service Worker Registration
            useEffect(() => {
                if ('serviceWorker' in navigator) {
                    window.addEventListener('load', () => {
                        navigator.serviceWorker.register('./service-worker.js')
                            .then(registration => {
                                console.log('SW registered:', registration);
                            })
                            .catch(registrationError => {
                                console.log('SW registration failed:', registrationError);
                            });
                    });
                }
            }, []);


            // Theme classes updated to use custom hex colors
            const modeClass = isDarkMode ? 'bg-dark-bg text-white' : 'bg-gray-100 text-gray-900 light-mode'; // Darker background
            const cardClass = isDarkMode ? 'bg-dark-card shadow-2xl' : 'bg-white shadow-lg border border-gray-200'; // Lighter card
            const sectionHeaderClass = isDarkMode ? 'bg-dark-card border-dark-bg' : 'bg-gray-100 border-gray-300'; // Card surface
            const sectionContentClass = isDarkMode ? 'bg-dark-card border-dark-bg' : 'bg-white border-gray-300'; // Card surface
            const tableHeaderClass = isDarkMode ? 'text-gray-400' : 'text-gray-600'; 
            const subtleTextColor = isDarkMode ? 'text-gray-500' : 'text-gray-500';
            const primaryTextColor = isDarkMode ? 'text-white' : 'text-gray-900';
            const inputClass = isDarkMode 
                ? 'bg-dark-bg border border-gray-600 text-white focus:ring-blue-500 focus:border-blue-500' // Darker input field
                : 'bg-white border border-gray-300 text-gray-900 focus:ring-blue-500 focus:border-blue-500';
            const errorClass = isDarkMode ? 'bg-red-900 border-red-700 text-red-300' : 'bg-red-100 border-red-400 text-red-800';


            // --- Computed Run Data (Unfiltered Laps with calculations) ---
            const computedLaps = useMemo(() => {
                const isSwimMode = activityType === 'SWIM';

                return laps.map(lap => {
                    // Raw data is the input from forms/API before processing
                    const rawDistance = lap.distance; 
                    const rawTime = lap.time; 
                    
                    const dist = parseFloat(rawDistance) || 0; 
                    const timeSec = timeToSeconds(rawTime);
                    // Use the application's current activity mode for pace calculation
                    const pace = calculatePace(timeSec, dist, isSwimMode);
                    const formattedTime = secondsToTimeString(timeSec);
                    
                    return { 
                        ...lap, 
                        timeSec, 
                        pace,
                        time: formattedTime, // formatted for display
                        distance: dist, // numerical distance (ALWAYS stored in KM)
                        rawDistance, // raw input for editing
                        rawTime // raw input for editing
                    };
                });
            }, [laps, activityType]); // Re-run if activityType changes


            // Filtered Laps based on user selection
            const allFilterableTypes = LAP_TYPES; // Use the global constant for filtering

            const filteredLaps = useMemo(() => {
                if (filterType === 'All') {
                    return computedLaps;
                } 
                if (allFilterableTypes.includes(filterType)) {
                     return computedLaps.filter(lap => lap.type === filterType);
                }
                return computedLaps;
            }, [computedLaps, filterType]);


            // Totals for the currently filtered view
            const filteredSummary = useMemo(() => {
                const isSwimMode = activityType === 'SWIM';
                let totalTimeSeconds = 0;
                let totalDistance = 0;
                
                filteredLaps.forEach(lap => {
                    totalTimeSeconds += lap.timeSec;
                    totalDistance += lap.distance;
                });

                const totalTimeStr = secondsToTimeString(totalTimeSeconds);
                // Use the application's current activity mode for pace calculation
                const avgPace = calculatePace(totalTimeSeconds, totalDistance, isSwimMode);

                return {
                    totalTimeSeconds,
                    totalDistance: totalDistance,
                    totalTimeStr,
                    avgPace
                };
            }, [filteredLaps, activityType]);


            // --- Lap Editing Handlers ---
            const handleSaveLap = (index, updatedLap) => {
                // Find the original lap object in the currently filtered view
                const filteredLapToUpdate = filteredLaps[index];

                // Find the index of this exact lap object in the UNFILTERED list (computedLaps)
                const originalIndex = computedLaps.findIndex(lap => 
                    lap.rawDistance === filteredLapToUpdate.rawDistance && 
                    lap.rawTime === filteredLapToUpdate.rawTime
                );

                if (originalIndex === -1) {
                     console.error("Could could not find lap to update in original array.");
                     return;
                }
                
                // Update the main 'laps' array (raw data array) which drives computedLaps
                const newLaps = [...laps];
                // The updatedLap contains: { type: string, distance: string (raw), time: string (raw)}
                newLaps[originalIndex] = {
                    type: updatedLap.type,
                    distance: updatedLap.distance, // Raw string distance
                    time: updatedLap.time // Raw time string
                };
                setLaps(newLaps);
                setIsEditing(false);
            };

            const handleCancelEdit = () => {
                setIsEditing(false);
            };

            // --- Manual Form Handlers ---
            const handleInputChange = (e) => {
                const { name, value } = e.target;
                setNewLap(prev => ({ ...prev, [name]: value }));
            };

            const handleAddLap = (e) => {
                e.preventDefault();
                const dist = newLap.distance.trim();
                const time = newLap.time.trim();
                
                if (parseFloat(dist) > 0 && timeToSeconds(time) > 0) {
                    setLaps(prev => [...prev, {
                        type: newLap.type,
                        distance: dist, // Store raw input (string)
                        time: time, // Store raw input (string)
                    }]);
                    setNewLap({ type: 'Run', distance: '', time: '' });
                } else {
                    setApiError("Invalid input: Distance must be > 0 and Time must be provided (e.g., '5' or '5:30.00').");
                    setTimeout(() => setApiError(''), 3000);
                }
            };

            const handleClearLaps = () => {
                // UPDATE: Clear localStorage as well
                localStorage.removeItem(STORAGE_KEY);
                setLaps([]);
                // Reset activity type when clearing all laps
                setActivityType('RUN');
                setShowSwimFilters(false);
                setFilterType('All');
            };
            
            // --- Image Processing Handlers ---
            const handleImageChange = (event) => {
                const file = event.target.files[0];
                if (file) {
                    setUploadedImage(file);
                    setApiError('');
                }
            };

            const processImageWithGemini = async () => {
                if (!uploadedImage) {
                    setApiError("Please upload an image first.");
                    setTimeout(() => setApiError(''), 3000);
                    return;
                }
                if (!apiKey) {
                    setApiError("API Key is missing in the code. Image analysis will fail.");
                    setTimeout(() => setApiError(''), 3000);
                    return;
                }

                setIsLoading(true);
                setApiError('');
                
                const reader = new FileReader();
                reader.readAsDataURL(uploadedImage);

                reader.onloadend = async () => {
                    const base64Data = reader.result.split(',')[1];
                    const mimeType = uploadedImage.type;
                    
                    const systemPrompt = `You are a data extraction expert. Your task is to extract the lap data (Lap Type, Distance in km, and Time) from the provided running stats image. Do NOT include the pace column or any total/summary rows. Use the exact type names found (e.g., 'Run', 'Rest', 'Warm Up', 'Cool Down', 'Freestyle', 'Breaststroke', 'Backstroke', 'Butterfly'). For time, preserve the original format as a string (e.g., 6:00.00). Provide the output as a JSON array strictly following the schema.`;
                    const userQuery = "Extract the lap type, distance, and time for every row in the table visible in this image.";
                    
                    const payload = {
                        contents: [
                            {
                                role: "user",
                                parts: [
                                    { text: userQuery },
                                    {
                                        inlineData: {
                                            mimeType: mimeType,
                                            data: base64Data 
                                        }
                                    }
                                ]
                            }
                        ],
                        systemInstruction: { parts: [{ text: systemPrompt }] },
                        generationConfig: {
                            responseMimeType: "application/json",
                            responseSchema: {
                                type: "ARRAY",
                                items: {
                                    type: "OBJECT",
                                    properties: {
                                        "type": { "type": "STRING", "description": "The type of activity (e.g., Run, Rest, Warm Up, Cool Down, Freestyle, etc.)." },
                                        "distance": { "type": "NUMBER", "description": "The distance covered in kilometers (e.g., 2.16)." },
                                        "time": { "type": "STRING", "description": "The time duration in M:SS.SS or H:MM:SS.SS format (e.g., 6:00.00)." }
                                    },
                                    required: ["type", "distance", "time"]
                                }
                            }
                        }
                    };
                    
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`; 

                    try {
                        let response;
                        const maxRetries = 3;
                        let delay = 1000;

                        for (let i = 0; i < maxRetries; i++) {
                            response = await fetch(apiUrl, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(payload)
                            });

                            if (response.ok) {
                                break;
                            }
                            if (i < maxRetries - 1) {
                                // Exponential backoff to handle throttling
                                console.warn(`API call failed (status: ${response.status}). Retrying in ${delay}ms...`);
                                await new Promise(resolve => setTimeout(resolve, delay));
                                delay *= 2; 
                            } else {
                                throw new Error(`API failed after ${maxRetries} attempts.`);
                            }
                        }
                        
                        const result = await response.json();
                        const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                        
                        if (jsonText) {
                            const extractedLaps = JSON.parse(jsonText);
                            if (Array.isArray(extractedLaps)) {
                                // Check if any extracted lap is a swim type
                                const containsSwim = extractedLaps.some(lap => SWIM_TYPES.includes(lap.type));
                                if (containsSwim) {
                                    setActivityType('SWIM');
                                    setShowSwimFilters(true);
                                }
                                
                                // Add new laps to existing list
                                setLaps(prev => [
                                    ...prev, 
                                    ...extractedLaps.map(lap => ({
                                        type: lap.type || 'Run',
                                        distance: lap.distance ? lap.distance.toString() : '0', // Ensure raw string distance is stored
                                        time: lap.time || '0:00.00'
                                    }))
                                ]);
                            } else {
                                throw new Error("Extraction returned invalid data format.");
                            }
                        } else {
                            throw new Error("Could not extract data from the image.");
                        }

                    } catch (error) {
                        console.error("API Error:", error);
                        alert(`Data extraction failed. Error: ${error.message}. Verify your image quality and API Key.`);
                    } finally {
                        setIsLoading(false);
                    }
                };
                reader.onerror = () => {
                    setIsLoading(false);
                    setApiError("Error reading the image file.");
                };
            };
            
            // --- Share Image Handler (Updated for Web Share API) ---
            const handleShareImage = () => {
                const input = document.getElementById('share-target-content');
                const totalRowElement = document.getElementById('total-lap-row'); // The specific total lap row
                const rootCard = document.getElementById('stats-card');
                
                if (!input || !rootCard || !totalRowElement) {
                    console.error("Internal Error: Could not find capture area elements.");
                    return;
                }

                // 1. Temporarily save and change styles for screenshot
                const originalRootClass = rootCard.className;
                const originalBodyBg = document.body.style.backgroundColor;
                const originalBodyClass = document.body.className;
                const originalTotalRowClass = totalRowElement.className;

                // Remove background/shadow from body and card for transparency
                document.body.style.backgroundColor = 'transparent';
                document.body.className = '';

                // Temporarily remove card background and shadow
                const isCurrentlyDark = rootCard.classList.contains('bg-dark-card'); // Check for new dark class
                const isCurrentlyLight = rootCard.classList.contains('bg-white');
                if (isCurrentlyDark) rootCard.classList.remove('bg-dark-card', 'shadow-2xl');
                if (isCurrentlyLight) rootCard.classList.remove('bg-white', 'shadow-lg', 'border');
                
                // Add temporary class to ensure borders/text remain visible if root is transparent
                rootCard.classList.add('bg-transparent', 'shadow-none'); 

                // Remove the colored background from the specific Total row element
                totalRowElement.classList.remove('bg-dark-bg', 'bg-gray-200'); // Check for new dark class
                totalRowElement.classList.add('bg-transparent'); 

                // 2. Use html2canvas to capture the element
                html2canvas(input, {
                    scale: 3, // Higher scale for better resolution
                    useCORS: true,
                    backgroundColor: null, // Critical for transparent PNG output
                    allowTaint: true
                }).then(canvas => {
                    // 3. Convert canvas to Blob for sharing/download
                    canvas.toBlob(async (blob) => {
                        // 4. Restore original styles immediately (critical to do this inside or right after the html2canvas promise)

                        // Restore total row styles
                        totalRowElement.className = originalTotalRowClass;

                        // Restore root card styles
                        rootCard.classList.remove('bg-transparent', 'shadow-none', 'border-none');
                        if (isCurrentlyDark) rootCard.classList.add('bg-dark-card', 'shadow-2xl');
                        if (isCurrentlyLight) rootCard.classList.add('bg-white', 'shadow-lg', 'border');
                        rootCard.className = originalRootClass; // Safest way is to restore original captured class list
                        
                        document.body.style.backgroundColor = originalBodyBg;
                        document.body.className = originalBodyClass;

                        // --- Share Logic: Attempt Download first, then Native Share ---

                        const handleDownloadFallback = (canvas) => {
                            const image = canvas.toDataURL('image/png');
                            const link = document.createElement('a');
                            link.href = image;
                            link.download = `running-stats-${new Date().toISOString().slice(0, 10)}.png`;
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                        }
                        
                        // A. Attempt Download (Reliable for Desktop, but can fail on strict mobile browsers)
                        try {
                            handleDownloadFallback(canvas);
                            console.log("Download initiated successfully.");
                            return; // Stop here if download worked
                        } catch (e) {
                            console.error("Direct download failed. Attempting native share as fallback. Error:", e);
                        }


                        // B. Attempt Native Web Share API (Best for "Save to Photos" on mobile when download fails)
                        if (navigator.share && blob) {
                            const file = new File([blob], `running-stats-${new Date().toISOString().slice(0, 10)}.png`, { type: 'image/png' });
                            
                            try {
                                await navigator.share({
                                    title: 'Running Stats',
                                    text: 'Check out my filtered running stats!',
                                    files: [file],
                                });
                            } catch (error) {
                                console.error('Native share failed or was dismissed. Error:', error);
                            }
                        } else {
                            console.log("Native Web Share API not supported or context is invalid for sharing.");
                        }


                    }, 'image/png');
                }).catch(err => {
                    console.error("Image capture failed:", err);
                    alert("Failed to generate image. Try another browser.");
                    
                    // Always restore styles even on error
                    totalRowElement.className = originalTotalRowClass;
                    rootCard.className = originalRootClass;
                    document.body.style.backgroundColor = originalBodyBg;
                    document.body.className = originalBodyClass;
                });
            };

            // --- UI Render ---
            return (
                <div className={`min-h-screen font-sans p-4 ${modeClass}`}>

                    {/* Theme Toggle Button */}
                    <div className="max-w-md mx-auto flex justify-end mb-4">
                         <button 
                            onClick={() => setIsDarkMode(!isDarkMode)}
                            className={`p-2 rounded-full transition duration-200 focus:outline-none 
                                ${isDarkMode ? 'bg-dark-card text-yellow-400 hover:bg-gray-700' : 'bg-gray-200 text-yellow-600 hover:bg-gray-300'}`}
                            title={isDarkMode ? "Switch to Light Mode" : "Switch to Dark Mode"}
                        >
                            {isDarkMode ? <SunIcon className="w-5 h-5 mr-0"/> : <MoonIcon className="w-5 h-5 mr-0"/>}
                        </button>
                    </div>

                    <div id="stats-card" className={`max-w-md mx-auto rounded-xl overflow-hidden ${cardClass}`}>
                        
                        {/* Image Upload Section (Collapsible) */}
                        <div className={`p-4 border-b ${sectionHeaderClass}`}>
                            <button 
                                onClick={() => setIsUploadExpanded(!isUploadExpanded)}
                                className={`w-full flex justify-between items-center text-lg font-semibold focus:outline-none ${primaryTextColor}`}
                                aria-expanded={isUploadExpanded}
                            >
                                <span className="flex items-center">
                                    <ImageIcon className="w-4 h-4 mr-2 text-green-400" stroke={isDarkMode ? 'currentColor' : '#10B981'}/> Upload Stats Image
                                </span>
                                {isUploadExpanded ? <ChevronUpIcon className="w-5 h-5 text-green-400"/> : <ChevronDownIcon className="w-5 h-5 text-green-400"/>}
                            </button>
                            
                            <div 
                                className="collapsible"
                                style={{ 
                                    maxHeight: isUploadExpanded ? '600px' : '0', 
                                    opacity: isUploadExpanded ? 1 : 0,
                                    marginTop: isUploadExpanded ? '1rem' : '0'
                                }}
                            >
                                <div className="space-y-3 mt-4">
                                    {/* File Uploader and Analyzer Button */}
                                    <div className="flex space-x-2 items-center">
                                        <label className="flex-1 min-w-0"> {/* FIX: Added min-w-0 to allow shrinkage */}
                                            <input
                                                type="file"
                                                accept="image/*"
                                                onChange={handleImageChange}
                                                className="block w-full text-sm text-gray-400"
                                            />
                                            {uploadedImage && (
                                                <p className={`mt-2 text-xs ${subtleTextColor} truncate`}>
                                                    File selected: {uploadedImage.name}
                                                </p>
                                            )}
                                        </label>
                                        
                                        <button
                                            type="button"
                                            onClick={processImageWithGemini}
                                            disabled={isLoading || !uploadedImage} 
                                            className={`w-28 py-2 rounded-lg shadow-lg flex items-center justify-center font-medium transition duration-150
                                                ${isLoading || !uploadedImage
                                                    ? 'bg-gray-600 text-gray-400 cursor-not-allowed'
                                                    : 'bg-green-600 hover:bg-green-700 text-white'
                                                }`}
                                        >
                                            <Loader2Icon className={`w-4 h-4 mr-2 ${isLoading ? 'animate-spin' : ''}`}/> Analyze
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>

                        {/* API Error Message */}
                        {apiError && (
                            <div className={`p-3 mx-4 my-2 rounded-lg text-sm font-medium ${errorClass}`}>
                                {apiError}
                            </div>
                        )}
                        
                        {/* Manual Lap Input Form (with Collapse/Expand) */}
                        <div className={`p-4 border-t ${sectionContentClass}`}>
                            <button 
                                onClick={() => setIsInputExpanded(!isInputExpanded)}
                                className={`w-full flex justify-between items-center text-lg font-semibold focus:outline-none ${primaryTextColor}`}
                                aria-expanded={isInputExpanded}
                            >
                                <span className="flex items-center">
                                    <BarChartIcon className="w-4 h-4 mr-2 text-blue-400" stroke={isDarkMode ? 'currentColor' : '#3B82F6'}/> Add New {activityType === 'SWIM' ? 'Swimming' : 'Running'} Lap Manually
                                </span>
                                {isInputExpanded ? <ChevronUpIcon className="w-5 h-5 text-blue-400"/> : <ChevronDownIcon className="w-5 h-5 text-blue-400"/>}
                            </button>

                            <div 
                                className="collapsible"
                                style={{ 
                                    maxHeight: isInputExpanded ? '500px' : '0', 
                                    opacity: isInputExpanded ? 1 : 0,
                                    marginTop: isInputExpanded ? '1rem' : '0'
                                }}
                            >
                                <form onSubmit={handleAddLap} className="space-y-3">
                                    <div className="flex space-x-2">
                                        <select
                                            name="type"
                                            value={newLap.type}
                                            onChange={handleInputChange}
                                            className={`w-1/3 p-2 rounded-lg text-sm ${inputClass}`}
                                        >
                                            {LAP_TYPES.map(type => <option key={type} value={type}>{type}</option>)}
                                        </select>
                                        <input
                                            type="text"
                                            name="distance"
                                            value={newLap.distance}
                                            onChange={handleInputChange}
                                            placeholder={`Distance (${activityType === 'SWIM' ? 'km' : 'km'})`}
                                            step="0.01"
                                            className={`w-1/3 p-2 rounded-lg text-sm ${inputClass}`}
                                        />
                                        <input
                                            type="text"
                                            name="time"
                                            value={newLap.time}
                                            onChange={handleInputChange}
                                            placeholder="Time (M or M:SS.SS)"
                                            className={`w-1/3 p-2 rounded-lg text-sm ${inputClass}`}
                                        />
                                    </div>
                                    <div className="flex space-x-2">
                                         <button
                                            type="submit"
                                            className="w-full bg-blue-600 hover:bg-blue-700 transition duration-150 text-white font-medium py-2 rounded-lg shadow-lg flex items-center justify-center"
                                        >
                                            <PlayIcon className="w-4 h-4 mr-2"/> Add Lap
                                        </button>
                                        <button
                                            type="button"
                                            onClick={handleClearLaps}
                                            className="w-1/3 bg-red-600 hover:bg-red-700 transition duration-150 text-white font-medium py-2 rounded-lg shadow-lg flex items-center justify-center"
                                        >
                                            <RefreshCwIcon className="w-3 h-3"/> Clear All
                                        </button>
                                    </div>
                                </form>
                            </div>
                        </div>

                        {/* NEW: Visualization Section (Collapsible) */}
                        <div className={`p-4 border-t ${sectionContentClass}`}>
                            <button 
                                onClick={() => setIsVisualizationExpanded(!isVisualizationExpanded)}
                                className={`w-full flex justify-between items-center text-lg font-semibold focus:outline-none ${primaryTextColor}`}
                                aria-expanded={isVisualizationExpanded}
                            >
                                <span className="flex items-center">
                                    <BarChartIcon className="w-4 h-4 mr-2 text-yellow-400" stroke={isDarkMode ? 'currentColor' : '#FBBF24'}/> Visualization & Comparison
                                </span>
                                {isVisualizationExpanded ? <ChevronUpIcon className="w-5 h-5 text-yellow-400"/> : <ChevronDownIcon className="w-5 h-5 text-yellow-400"/>}
                            </button>
                            
                            <div 
                                className="collapsible"
                                style={{ 
                                    maxHeight: isVisualizationExpanded ? '800px' : '0', 
                                    opacity: isVisualizationExpanded ? 1 : 0,
                                    marginTop: isVisualizationExpanded ? '1rem' : '0'
                                }}
                            >
                                {/* Chart Type Selector Buttons */}
                                <div className="flex space-x-2 mb-4">
                                    <ChartTypeButton 
                                        type="line" 
                                        currentType={chartType} 
                                        setType={setChartType} 
                                        label="Pace Trend (Line)" 
                                        isDarkMode={isDarkMode} 
                                    />
                                    <ChartTypeButton 
                                        type="horizontalBar" 
                                        currentType={chartType} 
                                        setType={setChartType} 
                                        label="Lap Comparison (Bar)" 
                                        isDarkMode={isDarkMode} 
                                    />
                                </div>
                                
                                <PaceChart filteredLaps={filteredLaps} isDarkMode={isDarkMode} activityType={activityType} chartType={chartType} />
                            </div>
                        </div>
                        
                        {/* LAP FILTERING SECTION */}
                        <div className={`p-4 border-t border-b ${sectionHeaderClass}`}>
                            <div className="flex justify-between items-center mb-3">
                                <h2 className={`text-sm font-semibold flex items-center uppercase tracking-wider ${primaryTextColor}`}>
                                    <FilterIcon className="w-4 h-4 mr-2 text-indigo-400" stroke={isDarkMode ? 'currentColor' : '#8B5CF6'}/> Filter Laps View
                                </h2>
                                <div className="flex space-x-2">
                                    <button
                                            type="button"
                                            onClick={handleClearLaps}
                                            className="py-1 px-3 rounded-lg text-xs font-medium transition duration-150 flex items-center bg-gray-600 hover:bg-red-700 text-white shadow-md"
                                        >
                                            <RefreshCwIcon className="w-3 h-3"/> Clear All
                                        </button>
                                    {/* NEW: Refresh Button */}
                                    <button
                                        onClick={() => window.location.reload()}
                                        className={`py-1 px-3 rounded-lg text-xs font-medium transition duration-150 flex items-center bg-gray-600 hover:bg-gray-700 text-white shadow-md`}
                                        title="Reload Page"
                                    >
                                        <RefreshCwIcon className="w-3 h-3 mr-1"/> Refresh
                                    </button>
                                    {/* Edit Button */}
                                    <button
                                        onClick={() => setIsEditing(prev => !prev)}
                                        className={`py-1 px-3 rounded-lg text-xs font-medium transition duration-150 flex items-center 
                                            ${isEditing 
                                                ? 'bg-red-600 hover:bg-red-700 text-white shadow-md' 
                                                : 'bg-indigo-600 hover:bg-indigo-700 text-white'
                                            }`}
                                    >
                                        <EditIcon className="w-3 h-3 mr-1"/> {isEditing ? 'Exit Edit' : 'Edit'}
                                    </button>
                                </div>
                            </div>
                            
                            {/* Filter buttons re-arranged as requested: Warm Up, Run, Rest, Cool Down */}
                            <div className="flex space-x-1 text-xs justify-between">
                                {/* Always show ALL button */}
                                <FilterButton type="All" currentFilter={filterType} setFilter={setFilterType} label="All" isDarkMode={isDarkMode} />
                                
                                {/* Dynamically show Running-related filters if they exist in the data */}
                                {existingLapTypes.has('Warm Up') && <FilterButton type="Warm Up" currentFilter={filterType} setFilter={setFilterType} label="Warm Up" isDarkMode={isDarkMode} />}
                                {existingLapTypes.has('Run') && <FilterButton type="Run" currentFilter={filterType} setFilter={setFilterType} label="Run" isDarkMode={isDarkMode} />}
                                {existingLapTypes.has('Rest') && <FilterButton type="Rest" currentFilter={filterType} setFilter={setFilterType} label="Rest" isDarkMode={isDarkMode} />}
                                {existingLapTypes.has('Cool Down') && <FilterButton type="Cool Down" currentFilter={filterType} setFilter={setFilterType} label="Cool Down" isDarkMode={isDarkMode} />}
                            </div>
                            
                            {/* NEW: Swimming filter buttons (Visible only if swim data is present and exists in laps) */}
                            {showSwimFilters && (
                                <div className="flex space-x-1 text-xs justify-between mt-2">
                                    {SWIM_TYPES.map(type => existingLapTypes.has(type) && (
                                        <FilterButton key={type} type={type} currentFilter={filterType} setFilter={setFilterType} label={type} isDarkMode={isDarkMode} />
                                    ))}
                                </div>
                            )}
                        </div>
                        
                        

                        {/* NEW CONTAINER: CAPTURE TARGET for PNG export */}
                        <div id="share-target-content">

                            {/* Lap Table Header */}
                            <div className="px-4 pt-4">
                                <div className={`grid grid-cols-12 text-xs font-semibold py-2 uppercase ${tableHeaderClass}`}>
                                    {/* Left-aligned Lap (Dynamically shows activity type) */}
                                    <div className="col-span-3 flex items-center">
                                         <ListOrderedIcon className="w-3 h-3 mr-1"/> {activityType === 'SWIM' ? 'SWIM' : 'LAP'}
                                    </div>
                                    {/* Right-aligned Distance (flex items-center for vertical alignment) */}
                                    <div className="col-span-3 text-right flex items-center justify-end whitespace-nowrap">
                                        <ActivityIcon className="w-3 h-3 mr-1"/> DISTANCE ({activityType === 'SWIM' ? 'M' : 'KM'})
                                    </div>
                                    {/* Right-aligned Time (flex items-center for vertical alignment) */}
                                    <div className="col-span-3 text-right flex items-center justify-end whitespace-nowrap">
                                        <ClockIcon className="w-3 h-3 mr-1"/> TIME
                                    </div>
                                    {/* Right-aligned Average Pace (flex items-center for vertical alignment) */}
                                    <div className="col-span-3 text-right flex items-center justify-end whitespace-nowrap">
                                        <StopwatchIcon className="w-3 h-3 mr-1"/> AVG PACE
                                    </div>
                                </div>
                            </div>

                            {/* Lap Table Rows (Dynamic height) */}
                            <div className="px-4">
                                {filteredLaps.map((lap, index) => (
                                    <LapRow 
                                        key={`${lap.rawTime}-${lap.rawDistance}-${index}`} 
                                        lap={lap} 
                                        index={index} 
                                        isDarkMode={isDarkMode} 
                                        isEditing={isEditing}
                                        onSave={(lapIndex, updatedData) => handleSaveLap(index, updatedData)} // Pass index from filteredLaps
                                        onCancel={handleCancelEdit}
                                        inputClass={inputClass}
                                        activityType={activityType}
                                    />
                                ))}
                                {filteredLaps.length === 0 && !isLoading && (
                                    <p className={`text-center py-8 ${subtleTextColor}`}>No laps recorded yet or no laps match the current filter criteria.</p>
                                )}
                            </div>

                            {/* Totals Summary Row (Uses LapRow component for formatting, but background will be stripped) */}
                            <div id="total-row-container">
                                <LapRow
                                    isTotal={true}
                                    lap={{
                                        type: 'Total',
                                        distance: filteredSummary.totalDistance,
                                        time: filteredSummary.totalTimeStr,
                                        pace: filteredSummary.avgPace,
                                    }}
                                    isDarkMode={isDarkMode}
                                    activityType={activityType}
                                />
                            </div>
                        </div>
                        {/* END CAPTURE TARGET */}
                        
                        {/* Centered Total Text - VISIBLE in UI, EXCLUDED from capture */}
                        <div className={`flex justify-center mt-4 text-xs ${subtleTextColor} space-x-4 px-4`}>
                            <p>Total Distance: <span className={`${primaryTextColor} font-medium`}>
                                {filteredSummary.totalDistance.toFixed(2)} {activityType === 'SWIM' ? 'km' : 'km'}
                            </span></p>
                            <p>Total Time: <span className={`${primaryTextColor} font-medium`}>{filteredSummary.totalTimeStr}</span></p>
                        </div>
                        
                        {/* Share Button */}
                        <div className={`p-4 border-t ${isDarkMode ? 'border-gray-700' : 'border-gray-300'} mt-4`}>
                            <button
                                onClick={handleShareImage}
                                className="w-full bg-indigo-600 hover:bg-indigo-700 transition duration-150 text-white font-medium py-3 rounded-lg shadow-xl flex items-center justify-center"
                                disabled={filteredLaps.length === 0}
                            >
                                <ShareIcon className="w-4 h-4 mr-2"/> Share Current Stats (PNG)
                            </button>
                        </div>
                    </div>
                    <div className={`text-center text-xs mt-4 ${subtleTextColor}`}>
                        Pace is calculated as Time per {activityType === 'SWIM' ? '100 Meters' : 'Kilometer'} (M'SS"/{activityType === 'SWIM' ? '100m' : 'km'}).
                    </div>
                </div>
            );
        };

        // Render the application
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
